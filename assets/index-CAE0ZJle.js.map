{"version":3,"file":"index-CAE0ZJle.js","sources":["../../node_modules/html-to-image/es/util.js","../../node_modules/html-to-image/es/clone-pseudos.js","../../node_modules/html-to-image/es/mimes.js","../../node_modules/html-to-image/es/dataurl.js","../../node_modules/html-to-image/es/clone-node.js","../../node_modules/html-to-image/es/embed-resources.js","../../node_modules/html-to-image/es/embed-images.js","../../node_modules/html-to-image/es/embed-webfonts.js","../../node_modules/html-to-image/es/index.js","../../node_modules/html-to-image/es/apply-style.js"],"sourcesContent":["export function resolveUrl(url, baseUrl) {\n    // url is absolute already\n    if (url.match(/^[a-z]+:\\/\\//i)) {\n        return url;\n    }\n    // url is absolute already, without protocol\n    if (url.match(/^\\/\\//)) {\n        return window.location.protocol + url;\n    }\n    // dataURI, mailto:, tel:, etc.\n    if (url.match(/^[a-z]+:/i)) {\n        return url;\n    }\n    const doc = document.implementation.createHTMLDocument();\n    const base = doc.createElement('base');\n    const a = doc.createElement('a');\n    doc.head.appendChild(base);\n    doc.body.appendChild(a);\n    if (baseUrl) {\n        base.href = baseUrl;\n    }\n    a.href = url;\n    return a.href;\n}\nexport const uuid = (() => {\n    // generate uuid for className of pseudo elements.\n    // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n    let counter = 0;\n    // ref: http://stackoverflow.com/a/6248722/2519373\n    const random = () => \n    // eslint-disable-next-line no-bitwise\n    `0000${((Math.random() * 36 ** 4) << 0).toString(36)}`.slice(-4);\n    return () => {\n        counter += 1;\n        return `u${random()}${counter}`;\n    };\n})();\nexport function delay(ms) {\n    return (args) => new Promise((resolve) => {\n        setTimeout(() => resolve(args), ms);\n    });\n}\nexport function toArray(arrayLike) {\n    const arr = [];\n    for (let i = 0, l = arrayLike.length; i < l; i++) {\n        arr.push(arrayLike[i]);\n    }\n    return arr;\n}\nlet styleProps = null;\nexport function getStyleProperties(options = {}) {\n    if (styleProps) {\n        return styleProps;\n    }\n    if (options.includeStyleProperties) {\n        styleProps = options.includeStyleProperties;\n        return styleProps;\n    }\n    styleProps = toArray(window.getComputedStyle(document.documentElement));\n    return styleProps;\n}\nfunction px(node, styleProperty) {\n    const win = node.ownerDocument.defaultView || window;\n    const val = win.getComputedStyle(node).getPropertyValue(styleProperty);\n    return val ? parseFloat(val.replace('px', '')) : 0;\n}\nfunction getNodeWidth(node) {\n    const leftBorder = px(node, 'border-left-width');\n    const rightBorder = px(node, 'border-right-width');\n    return node.clientWidth + leftBorder + rightBorder;\n}\nfunction getNodeHeight(node) {\n    const topBorder = px(node, 'border-top-width');\n    const bottomBorder = px(node, 'border-bottom-width');\n    return node.clientHeight + topBorder + bottomBorder;\n}\nexport function getImageSize(targetNode, options = {}) {\n    const width = options.width || getNodeWidth(targetNode);\n    const height = options.height || getNodeHeight(targetNode);\n    return { width, height };\n}\nexport function getPixelRatio() {\n    let ratio;\n    let FINAL_PROCESS;\n    try {\n        FINAL_PROCESS = process;\n    }\n    catch (e) {\n        // pass\n    }\n    const val = FINAL_PROCESS && FINAL_PROCESS.env\n        ? FINAL_PROCESS.env.devicePixelRatio\n        : null;\n    if (val) {\n        ratio = parseInt(val, 10);\n        if (Number.isNaN(ratio)) {\n            ratio = 1;\n        }\n    }\n    return ratio || window.devicePixelRatio || 1;\n}\n// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nconst canvasDimensionLimit = 16384;\nexport function checkCanvasDimensions(canvas) {\n    if (canvas.width > canvasDimensionLimit ||\n        canvas.height > canvasDimensionLimit) {\n        if (canvas.width > canvasDimensionLimit &&\n            canvas.height > canvasDimensionLimit) {\n            if (canvas.width > canvas.height) {\n                canvas.height *= canvasDimensionLimit / canvas.width;\n                canvas.width = canvasDimensionLimit;\n            }\n            else {\n                canvas.width *= canvasDimensionLimit / canvas.height;\n                canvas.height = canvasDimensionLimit;\n            }\n        }\n        else if (canvas.width > canvasDimensionLimit) {\n            canvas.height *= canvasDimensionLimit / canvas.width;\n            canvas.width = canvasDimensionLimit;\n        }\n        else {\n            canvas.width *= canvasDimensionLimit / canvas.height;\n            canvas.height = canvasDimensionLimit;\n        }\n    }\n}\nexport function canvasToBlob(canvas, options = {}) {\n    if (canvas.toBlob) {\n        return new Promise((resolve) => {\n            canvas.toBlob(resolve, options.type ? options.type : 'image/png', options.quality ? options.quality : 1);\n        });\n    }\n    return new Promise((resolve) => {\n        const binaryString = window.atob(canvas\n            .toDataURL(options.type ? options.type : undefined, options.quality ? options.quality : undefined)\n            .split(',')[1]);\n        const len = binaryString.length;\n        const binaryArray = new Uint8Array(len);\n        for (let i = 0; i < len; i += 1) {\n            binaryArray[i] = binaryString.charCodeAt(i);\n        }\n        resolve(new Blob([binaryArray], {\n            type: options.type ? options.type : 'image/png',\n        }));\n    });\n}\nexport function createImage(url) {\n    return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.onload = () => {\n            img.decode().then(() => {\n                requestAnimationFrame(() => resolve(img));\n            });\n        };\n        img.onerror = reject;\n        img.crossOrigin = 'anonymous';\n        img.decoding = 'async';\n        img.src = url;\n    });\n}\nexport async function svgToDataURL(svg) {\n    return Promise.resolve()\n        .then(() => new XMLSerializer().serializeToString(svg))\n        .then(encodeURIComponent)\n        .then((html) => `data:image/svg+xml;charset=utf-8,${html}`);\n}\nexport async function nodeToDataURL(node, width, height) {\n    const xmlns = 'http://www.w3.org/2000/svg';\n    const svg = document.createElementNS(xmlns, 'svg');\n    const foreignObject = document.createElementNS(xmlns, 'foreignObject');\n    svg.setAttribute('width', `${width}`);\n    svg.setAttribute('height', `${height}`);\n    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n    foreignObject.setAttribute('width', '100%');\n    foreignObject.setAttribute('height', '100%');\n    foreignObject.setAttribute('x', '0');\n    foreignObject.setAttribute('y', '0');\n    foreignObject.setAttribute('externalResourcesRequired', 'true');\n    svg.appendChild(foreignObject);\n    foreignObject.appendChild(node);\n    return svgToDataURL(svg);\n}\nexport const isInstanceOfElement = (node, instance) => {\n    if (node instanceof instance)\n        return true;\n    const nodePrototype = Object.getPrototypeOf(node);\n    if (nodePrototype === null)\n        return false;\n    return (nodePrototype.constructor.name === instance.name ||\n        isInstanceOfElement(nodePrototype, instance));\n};\n//# sourceMappingURL=util.js.map","import { uuid, getStyleProperties } from './util';\nfunction formatCSSText(style) {\n    const content = style.getPropertyValue('content');\n    return `${style.cssText} content: '${content.replace(/'|\"/g, '')}';`;\n}\nfunction formatCSSProperties(style, options) {\n    return getStyleProperties(options)\n        .map((name) => {\n        const value = style.getPropertyValue(name);\n        const priority = style.getPropertyPriority(name);\n        return `${name}: ${value}${priority ? ' !important' : ''};`;\n    })\n        .join(' ');\n}\nfunction getPseudoElementStyle(className, pseudo, style, options) {\n    const selector = `.${className}:${pseudo}`;\n    const cssText = style.cssText\n        ? formatCSSText(style)\n        : formatCSSProperties(style, options);\n    return document.createTextNode(`${selector}{${cssText}}`);\n}\nfunction clonePseudoElement(nativeNode, clonedNode, pseudo, options) {\n    const style = window.getComputedStyle(nativeNode, pseudo);\n    const content = style.getPropertyValue('content');\n    if (content === '' || content === 'none') {\n        return;\n    }\n    const className = uuid();\n    try {\n        clonedNode.className = `${clonedNode.className} ${className}`;\n    }\n    catch (err) {\n        return;\n    }\n    const styleElement = document.createElement('style');\n    styleElement.appendChild(getPseudoElementStyle(className, pseudo, style, options));\n    clonedNode.appendChild(styleElement);\n}\nexport function clonePseudoElements(nativeNode, clonedNode, options) {\n    clonePseudoElement(nativeNode, clonedNode, ':before', options);\n    clonePseudoElement(nativeNode, clonedNode, ':after', options);\n}\n//# sourceMappingURL=clone-pseudos.js.map","const WOFF = 'application/font-woff';\nconst JPEG = 'image/jpeg';\nconst mimes = {\n    woff: WOFF,\n    woff2: WOFF,\n    ttf: 'application/font-truetype',\n    eot: 'application/vnd.ms-fontobject',\n    png: 'image/png',\n    jpg: JPEG,\n    jpeg: JPEG,\n    gif: 'image/gif',\n    tiff: 'image/tiff',\n    svg: 'image/svg+xml',\n    webp: 'image/webp',\n};\nfunction getExtension(url) {\n    const match = /\\.([^./]*?)$/g.exec(url);\n    return match ? match[1] : '';\n}\nexport function getMimeType(url) {\n    const extension = getExtension(url).toLowerCase();\n    return mimes[extension] || '';\n}\n//# sourceMappingURL=mimes.js.map","function getContentFromDataUrl(dataURL) {\n    return dataURL.split(/,/)[1];\n}\nexport function isDataUrl(url) {\n    return url.search(/^(data:)/) !== -1;\n}\nexport function makeDataUrl(content, mimeType) {\n    return `data:${mimeType};base64,${content}`;\n}\nexport async function fetchAsDataURL(url, init, process) {\n    const res = await fetch(url, init);\n    if (res.status === 404) {\n        throw new Error(`Resource \"${res.url}\" not found`);\n    }\n    const blob = await res.blob();\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = () => {\n            try {\n                resolve(process({ res, result: reader.result }));\n            }\n            catch (error) {\n                reject(error);\n            }\n        };\n        reader.readAsDataURL(blob);\n    });\n}\nconst cache = {};\nfunction getCacheKey(url, contentType, includeQueryParams) {\n    let key = url.replace(/\\?.*/, '');\n    if (includeQueryParams) {\n        key = url;\n    }\n    // font resource\n    if (/ttf|otf|eot|woff2?/i.test(key)) {\n        key = key.replace(/.*\\//, '');\n    }\n    return contentType ? `[${contentType}]${key}` : key;\n}\nexport async function resourceToDataURL(resourceUrl, contentType, options) {\n    const cacheKey = getCacheKey(resourceUrl, contentType, options.includeQueryParams);\n    if (cache[cacheKey] != null) {\n        return cache[cacheKey];\n    }\n    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n    if (options.cacheBust) {\n        // eslint-disable-next-line no-param-reassign\n        resourceUrl += (/\\?/.test(resourceUrl) ? '&' : '?') + new Date().getTime();\n    }\n    let dataURL;\n    try {\n        const content = await fetchAsDataURL(resourceUrl, options.fetchRequestInit, ({ res, result }) => {\n            if (!contentType) {\n                // eslint-disable-next-line no-param-reassign\n                contentType = res.headers.get('Content-Type') || '';\n            }\n            return getContentFromDataUrl(result);\n        });\n        dataURL = makeDataUrl(content, contentType);\n    }\n    catch (error) {\n        dataURL = options.imagePlaceholder || '';\n        let msg = `Failed to fetch resource: ${resourceUrl}`;\n        if (error) {\n            msg = typeof error === 'string' ? error : error.message;\n        }\n        if (msg) {\n            console.warn(msg);\n        }\n    }\n    cache[cacheKey] = dataURL;\n    return dataURL;\n}\n//# sourceMappingURL=dataurl.js.map","import { clonePseudoElements } from './clone-pseudos';\nimport { createImage, toArray, isInstanceOfElement, getStyleProperties, } from './util';\nimport { getMimeType } from './mimes';\nimport { resourceToDataURL } from './dataurl';\nasync function cloneCanvasElement(canvas) {\n    const dataURL = canvas.toDataURL();\n    if (dataURL === 'data:,') {\n        return canvas.cloneNode(false);\n    }\n    return createImage(dataURL);\n}\nasync function cloneVideoElement(video, options) {\n    if (video.currentSrc) {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        canvas.width = video.clientWidth;\n        canvas.height = video.clientHeight;\n        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n        const dataURL = canvas.toDataURL();\n        return createImage(dataURL);\n    }\n    const poster = video.poster;\n    const contentType = getMimeType(poster);\n    const dataURL = await resourceToDataURL(poster, contentType, options);\n    return createImage(dataURL);\n}\nasync function cloneIFrameElement(iframe, options) {\n    var _a;\n    try {\n        if ((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body) {\n            return (await cloneNode(iframe.contentDocument.body, options, true));\n        }\n    }\n    catch (_b) {\n        // Failed to clone iframe\n    }\n    return iframe.cloneNode(false);\n}\nasync function cloneSingleNode(node, options) {\n    if (isInstanceOfElement(node, HTMLCanvasElement)) {\n        return cloneCanvasElement(node);\n    }\n    if (isInstanceOfElement(node, HTMLVideoElement)) {\n        return cloneVideoElement(node, options);\n    }\n    if (isInstanceOfElement(node, HTMLIFrameElement)) {\n        return cloneIFrameElement(node, options);\n    }\n    return node.cloneNode(isSVGElement(node));\n}\nconst isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === 'SLOT';\nconst isSVGElement = (node) => node.tagName != null && node.tagName.toUpperCase() === 'SVG';\nasync function cloneChildren(nativeNode, clonedNode, options) {\n    var _a, _b;\n    if (isSVGElement(clonedNode)) {\n        return clonedNode;\n    }\n    let children = [];\n    if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {\n        children = toArray(nativeNode.assignedNodes());\n    }\n    else if (isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n        ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {\n        children = toArray(nativeNode.contentDocument.body.childNodes);\n    }\n    else {\n        children = toArray(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);\n    }\n    if (children.length === 0 ||\n        isInstanceOfElement(nativeNode, HTMLVideoElement)) {\n        return clonedNode;\n    }\n    await children.reduce((deferred, child) => deferred\n        .then(() => cloneNode(child, options))\n        .then((clonedChild) => {\n        if (clonedChild) {\n            clonedNode.appendChild(clonedChild);\n        }\n    }), Promise.resolve());\n    return clonedNode;\n}\nfunction cloneCSSStyle(nativeNode, clonedNode, options) {\n    const targetStyle = clonedNode.style;\n    if (!targetStyle) {\n        return;\n    }\n    const sourceStyle = window.getComputedStyle(nativeNode);\n    if (sourceStyle.cssText) {\n        targetStyle.cssText = sourceStyle.cssText;\n        targetStyle.transformOrigin = sourceStyle.transformOrigin;\n    }\n    else {\n        getStyleProperties(options).forEach((name) => {\n            let value = sourceStyle.getPropertyValue(name);\n            if (name === 'font-size' && value.endsWith('px')) {\n                const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;\n                value = `${reducedFont}px`;\n            }\n            if (isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n                name === 'display' &&\n                value === 'inline') {\n                value = 'block';\n            }\n            if (name === 'd' && clonedNode.getAttribute('d')) {\n                value = `path(${clonedNode.getAttribute('d')})`;\n            }\n            targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));\n        });\n    }\n}\nfunction cloneInputValue(nativeNode, clonedNode) {\n    if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {\n        clonedNode.innerHTML = nativeNode.value;\n    }\n    if (isInstanceOfElement(nativeNode, HTMLInputElement)) {\n        clonedNode.setAttribute('value', nativeNode.value);\n    }\n}\nfunction cloneSelectValue(nativeNode, clonedNode) {\n    if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {\n        const clonedSelect = clonedNode;\n        const selectedOption = Array.from(clonedSelect.children).find((child) => nativeNode.value === child.getAttribute('value'));\n        if (selectedOption) {\n            selectedOption.setAttribute('selected', '');\n        }\n    }\n}\nfunction decorate(nativeNode, clonedNode, options) {\n    if (isInstanceOfElement(clonedNode, Element)) {\n        cloneCSSStyle(nativeNode, clonedNode, options);\n        clonePseudoElements(nativeNode, clonedNode, options);\n        cloneInputValue(nativeNode, clonedNode);\n        cloneSelectValue(nativeNode, clonedNode);\n    }\n    return clonedNode;\n}\nasync function ensureSVGSymbols(clone, options) {\n    const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : [];\n    if (uses.length === 0) {\n        return clone;\n    }\n    const processedDefs = {};\n    for (let i = 0; i < uses.length; i++) {\n        const use = uses[i];\n        const id = use.getAttribute('xlink:href');\n        if (id) {\n            const exist = clone.querySelector(id);\n            const definition = document.querySelector(id);\n            if (!exist && definition && !processedDefs[id]) {\n                // eslint-disable-next-line no-await-in-loop\n                processedDefs[id] = (await cloneNode(definition, options, true));\n            }\n        }\n    }\n    const nodes = Object.values(processedDefs);\n    if (nodes.length) {\n        const ns = 'http://www.w3.org/1999/xhtml';\n        const svg = document.createElementNS(ns, 'svg');\n        svg.setAttribute('xmlns', ns);\n        svg.style.position = 'absolute';\n        svg.style.width = '0';\n        svg.style.height = '0';\n        svg.style.overflow = 'hidden';\n        svg.style.display = 'none';\n        const defs = document.createElementNS(ns, 'defs');\n        svg.appendChild(defs);\n        for (let i = 0; i < nodes.length; i++) {\n            defs.appendChild(nodes[i]);\n        }\n        clone.appendChild(svg);\n    }\n    return clone;\n}\nexport async function cloneNode(node, options, isRoot) {\n    if (!isRoot && options.filter && !options.filter(node)) {\n        return null;\n    }\n    return Promise.resolve(node)\n        .then((clonedNode) => cloneSingleNode(clonedNode, options))\n        .then((clonedNode) => cloneChildren(node, clonedNode, options))\n        .then((clonedNode) => decorate(node, clonedNode, options))\n        .then((clonedNode) => ensureSVGSymbols(clonedNode, options));\n}\n//# sourceMappingURL=clone-node.js.map","import { resolveUrl } from './util';\nimport { getMimeType } from './mimes';\nimport { isDataUrl, makeDataUrl, resourceToDataURL } from './dataurl';\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g;\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nfunction toRegex(url) {\n    // eslint-disable-next-line no-useless-escape\n    const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n    return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, 'g');\n}\nexport function parseURLs(cssText) {\n    const urls = [];\n    cssText.replace(URL_REGEX, (raw, quotation, url) => {\n        urls.push(url);\n        return raw;\n    });\n    return urls.filter((url) => !isDataUrl(url));\n}\nexport async function embed(cssText, resourceURL, baseURL, options, getContentFromUrl) {\n    try {\n        const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;\n        const contentType = getMimeType(resourceURL);\n        let dataURL;\n        if (getContentFromUrl) {\n            const content = await getContentFromUrl(resolvedURL);\n            dataURL = makeDataUrl(content, contentType);\n        }\n        else {\n            dataURL = await resourceToDataURL(resolvedURL, contentType, options);\n        }\n        return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);\n    }\n    catch (error) {\n        // pass\n    }\n    return cssText;\n}\nfunction filterPreferredFontFormat(str, { preferredFontFormat }) {\n    return !preferredFontFormat\n        ? str\n        : str.replace(FONT_SRC_REGEX, (match) => {\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];\n                if (!format) {\n                    return '';\n                }\n                if (format === preferredFontFormat) {\n                    return `src: ${src};`;\n                }\n            }\n        });\n}\nexport function shouldEmbed(url) {\n    return url.search(URL_REGEX) !== -1;\n}\nexport async function embedResources(cssText, baseUrl, options) {\n    if (!shouldEmbed(cssText)) {\n        return cssText;\n    }\n    const filteredCSSText = filterPreferredFontFormat(cssText, options);\n    const urls = parseURLs(filteredCSSText);\n    return urls.reduce((deferred, url) => deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));\n}\n//# sourceMappingURL=embed-resources.js.map","import { embedResources } from './embed-resources';\nimport { toArray, isInstanceOfElement } from './util';\nimport { isDataUrl, resourceToDataURL } from './dataurl';\nimport { getMimeType } from './mimes';\nasync function embedProp(propName, node, options) {\n    var _a;\n    const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);\n    if (propValue) {\n        const cssString = await embedResources(propValue, null, options);\n        node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));\n        return true;\n    }\n    return false;\n}\nasync function embedBackground(clonedNode, options) {\n    ;\n    (await embedProp('background', clonedNode, options)) ||\n        (await embedProp('background-image', clonedNode, options));\n    (await embedProp('mask', clonedNode, options)) ||\n        (await embedProp('-webkit-mask', clonedNode, options)) ||\n        (await embedProp('mask-image', clonedNode, options)) ||\n        (await embedProp('-webkit-mask-image', clonedNode, options));\n}\nasync function embedImageNode(clonedNode, options) {\n    const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);\n    if (!(isImageElement && !isDataUrl(clonedNode.src)) &&\n        !(isInstanceOfElement(clonedNode, SVGImageElement) &&\n            !isDataUrl(clonedNode.href.baseVal))) {\n        return;\n    }\n    const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;\n    const dataURL = await resourceToDataURL(url, getMimeType(url), options);\n    await new Promise((resolve, reject) => {\n        clonedNode.onload = resolve;\n        clonedNode.onerror = options.onImageErrorHandler\n            ? (...attributes) => {\n                try {\n                    resolve(options.onImageErrorHandler(...attributes));\n                }\n                catch (error) {\n                    reject(error);\n                }\n            }\n            : reject;\n        const image = clonedNode;\n        if (image.decode) {\n            image.decode = resolve;\n        }\n        if (image.loading === 'lazy') {\n            image.loading = 'eager';\n        }\n        if (isImageElement) {\n            clonedNode.srcset = '';\n            clonedNode.src = dataURL;\n        }\n        else {\n            clonedNode.href.baseVal = dataURL;\n        }\n    });\n}\nasync function embedChildren(clonedNode, options) {\n    const children = toArray(clonedNode.childNodes);\n    const deferreds = children.map((child) => embedImages(child, options));\n    await Promise.all(deferreds).then(() => clonedNode);\n}\nexport async function embedImages(clonedNode, options) {\n    if (isInstanceOfElement(clonedNode, Element)) {\n        await embedBackground(clonedNode, options);\n        await embedImageNode(clonedNode, options);\n        await embedChildren(clonedNode, options);\n    }\n}\n//# sourceMappingURL=embed-images.js.map","import { toArray } from './util';\nimport { fetchAsDataURL } from './dataurl';\nimport { shouldEmbed, embedResources } from './embed-resources';\nconst cssFetchCache = {};\nasync function fetchCSS(url) {\n    let cache = cssFetchCache[url];\n    if (cache != null) {\n        return cache;\n    }\n    const res = await fetch(url);\n    const cssText = await res.text();\n    cache = { url, cssText };\n    cssFetchCache[url] = cache;\n    return cache;\n}\nasync function embedFonts(data, options) {\n    let cssText = data.cssText;\n    const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n    const fontLocs = cssText.match(/url\\([^)]+\\)/g) || [];\n    const loadFonts = fontLocs.map(async (loc) => {\n        let url = loc.replace(regexUrl, '$1');\n        if (!url.startsWith('https://')) {\n            url = new URL(url, data.url).href;\n        }\n        return fetchAsDataURL(url, options.fetchRequestInit, ({ result }) => {\n            cssText = cssText.replace(loc, `url(${result})`);\n            return [loc, result];\n        });\n    });\n    return Promise.all(loadFonts).then(() => cssText);\n}\nfunction parseCSS(source) {\n    if (source == null) {\n        return [];\n    }\n    const result = [];\n    const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi;\n    // strip out comments\n    let cssText = source.replace(commentsRegex, '');\n    // eslint-disable-next-line prefer-regex-literals\n    const keyframesRegex = new RegExp('((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})', 'gi');\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const matches = keyframesRegex.exec(cssText);\n        if (matches === null) {\n            break;\n        }\n        result.push(matches[0]);\n    }\n    cssText = cssText.replace(keyframesRegex, '');\n    const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi;\n    // to match css & media queries together\n    const combinedCSSRegex = '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' +\n        '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})';\n    // unified regex\n    const unifiedRegex = new RegExp(combinedCSSRegex, 'gi');\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        let matches = importRegex.exec(cssText);\n        if (matches === null) {\n            matches = unifiedRegex.exec(cssText);\n            if (matches === null) {\n                break;\n            }\n            else {\n                importRegex.lastIndex = unifiedRegex.lastIndex;\n            }\n        }\n        else {\n            unifiedRegex.lastIndex = importRegex.lastIndex;\n        }\n        result.push(matches[0]);\n    }\n    return result;\n}\nasync function getCSSRules(styleSheets, options) {\n    const ret = [];\n    const deferreds = [];\n    // First loop inlines imports\n    styleSheets.forEach((sheet) => {\n        if ('cssRules' in sheet) {\n            try {\n                toArray(sheet.cssRules || []).forEach((item, index) => {\n                    if (item.type === CSSRule.IMPORT_RULE) {\n                        let importIndex = index + 1;\n                        const url = item.href;\n                        const deferred = fetchCSS(url)\n                            .then((metadata) => embedFonts(metadata, options))\n                            .then((cssText) => parseCSS(cssText).forEach((rule) => {\n                            try {\n                                sheet.insertRule(rule, rule.startsWith('@import')\n                                    ? (importIndex += 1)\n                                    : sheet.cssRules.length);\n                            }\n                            catch (error) {\n                                console.error('Error inserting rule from remote css', {\n                                    rule,\n                                    error,\n                                });\n                            }\n                        }))\n                            .catch((e) => {\n                            console.error('Error loading remote css', e.toString());\n                        });\n                        deferreds.push(deferred);\n                    }\n                });\n            }\n            catch (e) {\n                const inline = styleSheets.find((a) => a.href == null) || document.styleSheets[0];\n                if (sheet.href != null) {\n                    deferreds.push(fetchCSS(sheet.href)\n                        .then((metadata) => embedFonts(metadata, options))\n                        .then((cssText) => parseCSS(cssText).forEach((rule) => {\n                        inline.insertRule(rule, inline.cssRules.length);\n                    }))\n                        .catch((err) => {\n                        console.error('Error loading remote stylesheet', err);\n                    }));\n                }\n                console.error('Error inlining remote css file', e);\n            }\n        }\n    });\n    return Promise.all(deferreds).then(() => {\n        // Second loop parses rules\n        styleSheets.forEach((sheet) => {\n            if ('cssRules' in sheet) {\n                try {\n                    toArray(sheet.cssRules || []).forEach((item) => {\n                        ret.push(item);\n                    });\n                }\n                catch (e) {\n                    console.error(`Error while reading CSS rules from ${sheet.href}`, e);\n                }\n            }\n        });\n        return ret;\n    });\n}\nfunction getWebFontRules(cssRules) {\n    return cssRules\n        .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\n        .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')));\n}\nasync function parseWebFontRules(node, options) {\n    if (node.ownerDocument == null) {\n        throw new Error('Provided element is not within a Document');\n    }\n    const styleSheets = toArray(node.ownerDocument.styleSheets);\n    const cssRules = await getCSSRules(styleSheets, options);\n    return getWebFontRules(cssRules);\n}\nfunction normalizeFontFamily(font) {\n    return font.trim().replace(/[\"']/g, '');\n}\nfunction getUsedFonts(node) {\n    const fonts = new Set();\n    function traverse(node) {\n        const fontFamily = node.style.fontFamily || getComputedStyle(node).fontFamily;\n        fontFamily.split(',').forEach((font) => {\n            fonts.add(normalizeFontFamily(font));\n        });\n        Array.from(node.children).forEach((child) => {\n            if (child instanceof HTMLElement) {\n                traverse(child);\n            }\n        });\n    }\n    traverse(node);\n    return fonts;\n}\nexport async function getWebFontCSS(node, options) {\n    const rules = await parseWebFontRules(node, options);\n    const usedFonts = getUsedFonts(node);\n    const cssTexts = await Promise.all(rules\n        .filter((rule) => usedFonts.has(normalizeFontFamily(rule.style.fontFamily)))\n        .map((rule) => {\n        const baseUrl = rule.parentStyleSheet\n            ? rule.parentStyleSheet.href\n            : null;\n        return embedResources(rule.cssText, baseUrl, options);\n    }));\n    return cssTexts.join('\\n');\n}\nexport async function embedWebFonts(clonedNode, options) {\n    const cssText = options.fontEmbedCSS != null\n        ? options.fontEmbedCSS\n        : options.skipFonts\n            ? null\n            : await getWebFontCSS(clonedNode, options);\n    if (cssText) {\n        const styleNode = document.createElement('style');\n        const sytleContent = document.createTextNode(cssText);\n        styleNode.appendChild(sytleContent);\n        if (clonedNode.firstChild) {\n            clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n        }\n        else {\n            clonedNode.appendChild(styleNode);\n        }\n    }\n}\n//# sourceMappingURL=embed-webfonts.js.map","import { cloneNode } from './clone-node';\nimport { embedImages } from './embed-images';\nimport { applyStyle } from './apply-style';\nimport { embedWebFonts, getWebFontCSS } from './embed-webfonts';\nimport { getImageSize, getPixelRatio, createImage, canvasToBlob, nodeToDataURL, checkCanvasDimensions, } from './util';\nexport async function toSvg(node, options = {}) {\n    const { width, height } = getImageSize(node, options);\n    const clonedNode = (await cloneNode(node, options, true));\n    await embedWebFonts(clonedNode, options);\n    await embedImages(clonedNode, options);\n    applyStyle(clonedNode, options);\n    const datauri = await nodeToDataURL(clonedNode, width, height);\n    return datauri;\n}\nexport async function toCanvas(node, options = {}) {\n    const { width, height } = getImageSize(node, options);\n    const svg = await toSvg(node, options);\n    const img = await createImage(svg);\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    const ratio = options.pixelRatio || getPixelRatio();\n    const canvasWidth = options.canvasWidth || width;\n    const canvasHeight = options.canvasHeight || height;\n    canvas.width = canvasWidth * ratio;\n    canvas.height = canvasHeight * ratio;\n    if (!options.skipAutoScale) {\n        checkCanvasDimensions(canvas);\n    }\n    canvas.style.width = `${canvasWidth}`;\n    canvas.style.height = `${canvasHeight}`;\n    if (options.backgroundColor) {\n        context.fillStyle = options.backgroundColor;\n        context.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    context.drawImage(img, 0, 0, canvas.width, canvas.height);\n    return canvas;\n}\nexport async function toPixelData(node, options = {}) {\n    const { width, height } = getImageSize(node, options);\n    const canvas = await toCanvas(node, options);\n    const ctx = canvas.getContext('2d');\n    return ctx.getImageData(0, 0, width, height).data;\n}\nexport async function toPng(node, options = {}) {\n    const canvas = await toCanvas(node, options);\n    return canvas.toDataURL();\n}\nexport async function toJpeg(node, options = {}) {\n    const canvas = await toCanvas(node, options);\n    return canvas.toDataURL('image/jpeg', options.quality || 1);\n}\nexport async function toBlob(node, options = {}) {\n    const canvas = await toCanvas(node, options);\n    const blob = await canvasToBlob(canvas);\n    return blob;\n}\nexport async function getFontEmbedCSS(node, options = {}) {\n    return getWebFontCSS(node, options);\n}\n//# sourceMappingURL=index.js.map","export function applyStyle(node, options) {\n    const { style } = node;\n    if (options.backgroundColor) {\n        style.backgroundColor = options.backgroundColor;\n    }\n    if (options.width) {\n        style.width = `${options.width}px`;\n    }\n    if (options.height) {\n        style.height = `${options.height}px`;\n    }\n    const manual = options.style;\n    if (manual != null) {\n        Object.keys(manual).forEach((key) => {\n            style[key] = manual[key];\n        });\n    }\n    return node;\n}\n//# sourceMappingURL=apply-style.js.map"],"names":["uuid","counter","Math","random","toString","slice","toArray","arrayLike","arr","i","l","length","push","styleProps","getStyleProperties","options","includeStyleProperties","window","getComputedStyle","document","documentElement","px","node","styleProperty","val","ownerDocument","defaultView","getPropertyValue","parseFloat","replace","getImageSize","targetNode","width","leftBorder","rightBorder","clientWidth","getNodeWidth","height","topBorder","bottomBorder","clientHeight","getNodeHeight","canvasDimensionLimit","createImage","url","Promise","resolve","reject","img","Image","onload","decode","then","requestAnimationFrame","onerror","crossOrigin","decoding","src","async","nodeToDataURL","xmlns","svg","createElementNS","foreignObject","setAttribute","appendChild","XMLSerializer","serializeToString","encodeURIComponent","html","svgToDataURL","isInstanceOfElement","instance","nodePrototype","Object","getPrototypeOf","constructor","name","getPseudoElementStyle","className","pseudo","style","selector","cssText","content","formatCSSText","map","getPropertyPriority","join","formatCSSProperties","createTextNode","clonePseudoElement","nativeNode","clonedNode","err","styleElement","createElement","WOFF","JPEG","mimes","woff","woff2","ttf","eot","png","jpg","jpeg","gif","tiff","webp","getMimeType","extension","match","exec","getExtension","toLowerCase","isDataUrl","search","fetchAsDataURL","init","process","res","fetch","status","Error","blob","reader","FileReader","onloadend","result","error","readAsDataURL","cache","resourceToDataURL","resourceUrl","contentType","cacheKey","includeQueryParams","key","test","getCacheKey","dataURL","cacheBust","Date","getTime","fetchRequestInit","headers","get","split","getContentFromDataUrl","mimeType","makeDataUrl","imagePlaceholder","msg","message","cloneSingleNode","HTMLCanvasElement","canvas","toDataURL","cloneNode","cloneCanvasElement","HTMLVideoElement","video","currentSrc","ctx","getContext","drawImage","poster","cloneVideoElement","HTMLIFrameElement","iframe","_a","contentDocument","body","_b","cloneIFrameElement","isSVGElement","isSlotElement","tagName","toUpperCase","decorate","Element","targetStyle","sourceStyle","transformOrigin","forEach","value","endsWith","reducedFont","floor","substring","getAttribute","setProperty","cloneCSSStyle","clonePseudoElements","HTMLTextAreaElement","innerHTML","HTMLInputElement","cloneInputValue","HTMLSelectElement","clonedSelect","selectedOption","Array","from","children","find","child","cloneSelectValue","isRoot","filter","assignedNodes","childNodes","shadowRoot","reduce","deferred","clonedChild","cloneChildren","clone","uses","querySelectorAll","processedDefs","id","exist","querySelector","definition","nodes","values","ns","position","overflow","display","defs","ensureSVGSymbols","URL_REGEX","URL_WITH_FORMAT_REGEX","FONT_SRC_REGEX","embed","resourceURL","baseURL","getContentFromUrl","resolvedURL","baseUrl","location","protocol","doc","implementation","createHTMLDocument","base","a","head","href","resolveUrl","escaped","RegExp","toRegex","shouldEmbed","embedResources","filteredCSSText","str","preferredFontFormat","format","filterPreferredFontFormat","urls","raw","quotation","parseURLs","css","embedProp","propName","propValue","cssString","embedImages","embedBackground","isImageElement","HTMLImageElement","SVGImageElement","baseVal","onImageErrorHandler","attributes","image","loading","srcset","embedImageNode","deferreds","all","embedChildren","cssFetchCache","fetchCSS","text","embedFonts","data","regexUrl","loadFonts","loc","startsWith","URL","parseCSS","source","keyframesRegex","matches","importRegex","unifiedRegex","lastIndex","parseWebFontRules","styleSheets","cssRules","ret","sheet","item","index","type","CSSRule","IMPORT_RULE","importIndex","metadata","rule","insertRule","catch","e","inline","getCSSRules","FONT_FACE_RULE","getWebFontRules","normalizeFontFamily","font","trim","getWebFontCSS","rules","usedFonts","fonts","Set","traverse","fontFamily","add","HTMLElement","getUsedFonts","has","parentStyleSheet","toSvg","fontEmbedCSS","skipFonts","styleNode","sytleContent","firstChild","insertBefore","embedWebFonts","backgroundColor","manual","keys","applyStyle","toCanvas","context","ratio","pixelRatio","FINAL_PROCESS","env","devicePixelRatio","parseInt","Number","isNaN","getPixelRatio","canvasWidth","canvasHeight","skipAutoScale","checkCanvasDimensions","fillStyle","fillRect","toPng"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9]}